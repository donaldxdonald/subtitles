[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1920
PlayResY: 1080

[Aegisub Project Garbage]
Audio File: D:/Videos/Translate/Marijn Haverbeke- Salvaging contentEditable- Building a Robust WYSIWYG Editor - JSConf EU 2015/Marijn Haverbeke- Salvaging contentEditable- Building a Robust WYSIWYG Editor - JSConf EU 2015.mp4
Video File: D:/Videos/Translate/Marijn Haverbeke- Salvaging contentEditable- Building a Robust WYSIWYG Editor - JSConf EU 2015/Marijn Haverbeke- Salvaging contentEditable- Building a Robust WYSIWYG Editor - JSConf EU 2015.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.625000
Scroll Position: 42
Active Line: 70
Video Position: 12399

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: CHS,霞鹜文楷,57,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1,1,2,10,10,10,1
Style: ENG,Jost,45,&H0000FFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1,1,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:26.00,0:00:38.00,CHS,,0,0,0,,谢谢，我今天要讲的是如何在浏览器中构建一个实用的所见即所得 \N {\rENG} Thank you, what I am going to talk about here today is how to build a robust WYSIWYM editor
Dialogue: 0,0:00:38.00,0:00:41.00,CHS,,0,0,0,,编辑器。 \N {\rENG} in the browser.
Dialogue: 0,0:00:41.00,0:00:46.00,CHS,,0,0,0,,所见即所得，我们通常的意思是 \N {\rENG} By what you see is what you mean, we usually mean something like
Dialogue: 0,0:00:46.00,0:00:52.00,CHS,,0,0,0,,所见即所得，您可以直观地展示您的内容，并且可以以 \N {\rENG} get, WYSIWYG where you have a visual representation of your content and can just edit that in the
Dialogue: 0,0:00:52.00,0:01:00.00,CHS,,0,0,0,,明显的光标选择方式对其进行编辑，而不是编辑 \N {\rENG} obvious classical way of cursor and selection, but instead of editing things like
Dialogue: 0,0:01:00.00,0:01:08.00,CHS,,0,0,0,,字体之类的东西 大小边距这些信息，因此您可以对 \N {\rENG} font size margins of your editing semantic information so you get reduced cleaner representation
Dialogue: 0,0:01:08.00,0:01:15.00,CHS,,0,0,0,,文档有更清晰的表示，您说这是一个段落，这是一个链接，而不是格鲁吉亚 15 \N {\rENG} of the document where you say this is a paragraph,this is a link, and not this is Georgia 15
Dialogue: 0,0:01:15.00,0:01:19.00,CHS,,0,0,0,,像素斜体。 \N {\rENG} pixels italic.
Dialogue: 0,0:01:19.00,0:01:25.00,CHS,,0,0,0,,当您想让用户编辑内容，然后您 \N {\rENG} This is usually beneficial when you want to have users edit content and you then later
Dialogue: 0,0:01:25.00,0:01:31.00,CHS,,0,0,0,,想在不同的上下文中以不同的布局使用它，或者您想检查它 \N {\rENG} want to use it in a different layout in a different context or you want to inspect it,
Dialogue: 0,0:01:31.00,0:01:37.00,CHS,,0,0,0,,并以某种方式对其进行转换时，这通常就很有用了，拥有相关的语义化信息比 \N {\rENG} and transform it somehow, it's very useful to have semantic information about the content
Dialogue: 0,0:01:37.00,0:01:41.00,CHS,,0,0,0,,仅仅是布局信息有用多了。 \N {\rENG} rather than just layout information.
Dialogue: 0,0:01:41.00,0:01:49.00,CHS,,0,0,0,,所以，我的最新项目叫做 ProseMirror。 我会说到 CodeMirror \N {\rENG} So, my newest project is called ProseMirror. I am going to be talking about CodeMirror
Dialogue: 0,0:01:49.00,0:01:54.50,CHS,,0,0,0,,和 ProseMirror。你不应该混淆它们， CodeMirror 是一个代码编辑器 \N {\rENG} and ProseMirror. You shouldn't confuse them, CodeMirror is a code editor
Dialogue: 0,0:01:54.60,0:02:04.00,CHS,,0,0,0,,ProseMirror 是一个语义化的富文本编辑器，有点像所见即所得，但内容干净。 \N {\rENG}  ProseMirror is a semantic rich text editor, so something like a WYSIWYG but for clean content.
Dialogue: 0,0:02:04.62,0:02:12.00,CHS,,0,0,0,,这是最近推出并开源的，我尝试构建这么一个编辑器 \N {\rENG} This was recently launched and open sourced and it's my attempt to build an editor where
Dialogue: 0,0:02:12.00,0:02:20.00,CHS,,0,0,0,,使您可以用它为您的内容定义范式并让编辑器自动执行该操作 \N {\rENG} you can define a schema for you content and have the editor automatically enforce that
Dialogue: 0,0:02:20.00,0:02:25.00,CHS,,0,0,0,,并为用户提供在您的范式规则内的编辑操作，例如，如果您有 \N {\rENG} and provide the user with editing actions that stay within your schema so if you have
Dialogue: 0,0:02:25.00,0:02:32.00,CHS,,0,0,0,,Github 你有你的文档模型，其中包括对 Issues 和 \N {\rENG} for example your Github you have you document model that includes references to issues and
Dialogue: 0,0:02:32.00,0:02:38.00,CHS,,0,0,0,,commits 的引用。你可以扩展你的文档模型来拥有第一个子句，现在它是 commit 的 \N {\rENG} commits you can extend your document model to have first clause. Now it's links to commits
Dialogue: 0,0:02:38.00,0:02:45.00,CHS,,0,0,0,,链接或用户的链接或其他任何东西，并且你的用户实际上正在使用对应的数据模型 \N {\rENG} or links to users or whatever and have your users actually be working with a data model
Dialogue: 0,0:02:45.00,0:02:50.00,CHS,,0,0,0,,你真正想要使用的东西。 \N {\rENG} that corresponds to what you actually wantto work with.
Dialogue: 0,0:02:50.00,0:02:59.00,CHS,,0,0,0,,ProseMirror 还支持协同编辑，因为我对未来 \N {\rENG} ProseMirror also supports collaborative editing and is generally I hope the future of in-browser
Dialogue: 0,0:02:59.00,0:03:01.00,CHS,,0,0,0,,在浏览器上写作很有信心。 \N {\rENG} prose writing.
Dialogue: 0,0:03:01.70,0:03:05.70,CHS,,0,0,0,,所以是的，我将会谈谈它是如何实现的 \N {\rENG} So yeah I am going to be talking about how it's implemented
Dialogue: 0,0:03:06.00,0:03:17.00,CHS,,0,0,0,,大部分的富文本编辑器实现的一个主要因素是名为 contentEditable 的浏览器 API。 \N {\rENG}a major factor in any kind of rich text editing implementation is the browser API called contentEditable.
Dialogue: 0,0:03:17.00,0:03:25.42,CHS,,0,0,0,,这是许多浏览器的所见即所得编辑器存在的原因 \N {\rENG} This is what enables many browser almost or in-browser WYSIWYGs to exist at all
Dialogue: 0,0:03:25.60,0:03:35.00,CHS,,0,0,0,,如果您与使用它的人交谈，您会听到抱怨和许多可怕的故事 \N {\rENG} If you talk to people who have worked with it you will get complaints and lots of horrible stories
Dialogue: 0,0:03:35.00,0:03:40.00,CHS,,0,0,0,,那么让我来介绍一些背景历史 \N {\rENG} So let me give a bit of background history
Dialogue: 0,0:03:40.00,0:03:47.00,CHS,,0,0,0,,这一年是 1979 年，微软在浏览器方面进展顺利，他们只是移植了 \N {\rENG} The year is 1979, Microsoft is on a roll when it comes to browser they just ported
Dialogue: 0,0:03:47.00,0:03:53.00,CHS,,0,0,0,,JavaScript，引入了动态 DOM 操作，然后我真的不知道发生了什么 \N {\rENG} JavaScript, introduced dynamic DOM manipulation. And then I guess I don't really know what happened
Dialogue: 0,0:03:53.00,0:03:59.00,CHS,,0,0,0,,但假设那时有人说让我们制作我们的浏览器和编辑器，这样人们就可以 \N {\rENG} but assume someone there said let's make our browser and editor so people can write HTML
Dialogue: 0,0:03:59.00,0:04:03.84,CHS,,0,0,0,,在浏览器中编写 HTML 。这是一个非常值得称道的想法。 \N {\rENG} in the browser. And this is a very commendable idea definitely
Dialogue: 0,0:04:04.32,0:04:10.16,CHS,,0,0,0,,他们最终在 IE 4 中所做的是引入了一个名为 designMode 的功能 \N {\rENG} What they ended up doing in IE 4 is introducing a feature called designMode
Dialogue: 0,0:04:10.38,0:04:15.50,CHS,,0,0,0,,这是在 document 上设置的一个属性，它使整个文档可编辑 \N {\rENG} It's a property you set on your document which makes the whole document editable 
Dialogue: 0,0:04:16.58,0:04:21.26,CHS,,0,0,0,,但是它的含义仍然不是很清楚， 没有涵盖此属性的规范你可以输入它 你可以退格 \N {\rENG} But what it means is still not clear. there's no spec that covers this you can type into it you can back space
Dialogue: 0,0:04:21.26,0:04:25.94,CHS,,0,0,0,,基本上，你会得到一个光标和一个选区，你可以在其中打字，可以退格\N {\rENG} Basically you get a cursor and a selection and you can type into it you can back space
Dialogue: 0,0:04:26.60,0:04:34.30,CHS,,0,0,0,,和这个 API 的搭配的是 document.execCommand，您的脚本可以将字符串 \N {\rENG} And a companion to this API is document.execCommand which your scripts can parse string
Dialogue: 0,0:04:34.64,0:04:45.18,CHS,,0,0,0,,转变为粗体、斜体或插入、删除有序列表或者对文档执行其他编辑操作 \N {\rENG} like bold or italic or insert ordered listor delete to perform other editing actions on the document
Dialogue: 0,0:04:45.52,0:04:54.00,CHS,,0,0,0,,自从 IE 4 以来，您可以做的是建立一个框架，将其设置为可编辑 \N {\rENG} What you could do since IE 4 is create a frame, set it to be editable
Dialogue: 0,0:04:54.00,0:05:04.00,CHS,,0,0,0,,然后绑定一些按键和按钮，以及各种执行命令代码，你就会有一个基本的所见即所得的编辑器 \N {\rENG}  And then bind some key binding and buttons some various exec command codes you would have a basic WYSIWYG editor
Dialogue: 0,0:05:04.00,0:05:11.00,CHS,,0,0,0,,这自 1997 年以来一直有效，然后在 2000 年，他们添加了第二个与之很像的功能， \N {\rENG} This has worked since 1997, then in 2000 they added a second feature very similar to that
Dialogue: 0,0:05:11.00,0:05:18.00,CHS,,0,0,0,,称为 contentEditable，和 designMode 一样，但针对的是每个 DOM 节点而不是整个文档 \N {\rENG} called contentEditable. This is the same as designMode but per DOM node instead of the whole document
Dialogue: 0,0:05:18.00,0:05:24.00,CHS,,0,0,0,,意味着您不必创建 iFrame，只需在现有内容中设置开关 \N {\rENG} Meaning you don't have to create an iFrame. You can just in your existing content set the switch
Dialogue: 0,0:05:24.00,0:05:31.20,CHS,,0,0,0,,以使其可编辑，让您的用户将某些内容添加到您的页面中，然后以某种方式保存它 \N {\rENG} to make it editable to let your users add something to a piece of your page then save it somehow
Dialogue: 0,0:05:33.00,0:05:40.00,CHS,,0,0,0,,自从引入此功能以来，您还可以做的是将可编辑 \N {\rENG} Other important thing you could do since this feature was introduced was set pieces of an editable
Dialogue: 0,0:05:40.00,0:05:46.00,CHS,,0,0,0,,DOM 节点的一部分设置为不可编辑，您可以在节点内部将其设置回 false  \N {\rENG} DOM node to be non editable you could set it back to false to be inside of the node,
Dialogue: 0,0:05:46.00,0:05:53.00,CHS,,0,0,0,,这意味着用户可以很好地编辑文本，但他们无法将光标移动 \N {\rENG} that means that well the users can edit text round it but they can't move their cursor
Dialogue: 0,0:05:53.00,0:05:55.00,CHS,,0,0,0,,到该节点并在那里开始编辑 \N {\rENG} into that node and start editing there
Dialogue: 0,0:05:55.00,0:06:00.00,CHS,,0,0,0,,这也是一个很大的改进，它允许您保护文档的某些部分 \N {\rENG} This is also a big improvement, it allows you to protect some part of your document
Dialogue: 0,0:06:00.00,0:06:06.00,CHS,,0,0,0,,或插入不一定可编辑的小部件 \N {\rENG} or insert widgets that are not necessarily editable
Dialogue: 0,0:06:06.00,0:06:12.00,CHS,,0,0,0,,所以，这几乎是在 JavaScript 大繁荣之前的事了，人们慢慢开始使用它 \N {\rENG} So, this was pretty much before the big JavaScript boom but people were slowly starting to use
Dialogue: 0,0:06:12.00,0:06:21.00,CHS,,0,0,0,,但在某个时候它变得非常广泛传播，CKEditor 应该是 2000 年代初期的 \N {\rENG} this at some point it become really wide spread, I think CKEditor is from the early 2000s
Dialogue: 0,0:06:21.00,0:06:29.20,CHS,,0,0,0,,不确定 TinyMCE 何时开始，有一些使用这个 API 的库，人们会在内容管理系统中使用它们 \N {\rENG} not sure when TinyMCE started. There were libraries reping this and people using this to CMS
Dialogue: 0,0:06:29.60,0:06:39.00,CHS,,0,0,0,,在 Mozilla ，我们有一种感觉，认为必须做这样的事情，这是一个有用的功能 \N {\rENG} At Mozilla there was a feeling we have todo something like this, it's a useful feature
Dialogue: 0,0:06:39.00,0:06:44.00,CHS,,0,0,0,,但他们不太喜欢微软所做的，这是浏览器大战，所以 \N {\rENG} but they didn't quite like what Microsoft had done, and this was the browser war so
Dialogue: 0,0:06:44.00,0:06:50.00,CHS,,0,0,0,,没有很好的标准规范沟通过程 \N {\rENG} it was not like there was a very good communication of standards process
Dialogue: 0,0:06:50.00,0:06:56.20,CHS,,0,0,0,,他们花了一些时间试图提出一个更好的解决方案，但他们从未真正就某件事达成一致 \N {\rENG} They spent sometime trying to come up witha better solution but they never really agreed on something
Dialogue: 0,0:06:56.54,0:07:02.00,CHS,,0,0,0,,所以最后他们说"好的"，我们只做了 Internet Explorer 所做的事情，这样我们就不再 \N {\rENG} So in the end they said ok we'll just do what Internet Explorer does so we're no longer
Dialogue: 0,0:07:02.00,0:07:06.80,CHS,,0,0,0,,被排除在浏览器富文本编辑器之外 \N {\rENG} left out when it comes to rich text editor in browser with text editing
Dialogue: 0,0:07:07.18,0:07:12.00,CHS,,0,0,0,,所以他们复制了这个功能，当然并没有完全复制它，他们的某些 \N {\rENG} So they copied this feature, of course it didn't exactly copy it they some parts of
Dialogue: 0,0:07:12.00,0:07:17.00,CHS,,0,0,0,,部分没有用，他们忽略了这些部分，他们认为他们知道其他部分的更好解决方案 \N {\rENG} it were no use they left those out, they thought they knew better solutions for some other
Dialogue: 0,0:07:17.00,0:07:23.00,CHS,,0,0,0,,例如，如果你将文字加粗，IE 会添加（听不清）文本，他们说不，我们上面 \N {\rENG} parts for example where IE would add &*% text if you made something bold, they said no we
Dialogue: 0,0:07:23.00,0:07:27.00,CHS,,0,0,0,,有字体宽度的 CSS。 \N {\rENG} have CSS that font width on them.
Dialogue: 0,0:07:27.50,0:07:30.24,CHS,,0,0,0,,我也不清楚为啥  \N {\rENG} I'm not sure why
Dialogue: 0,0:07:32.58,0:07:38.00,CHS,,0,0,0,,在当时两个主要浏览器上都有该功能 \N {\rENG} You had the feature on both major browsers then and a few years later
Dialogue: 0,0:07:38.00,0:07:47.00,CHS,,0,0,0,,直到 2007 年，在 JavaScript 热潮之后，Firefox 也添加了对 contentEditable 的支持 \N {\rENG} actually took until 2007 which is past the JavaScript boom that Firefox also added support for contentEditable
Dialogue: 0,0:07:47.00,0:07:54.00,CHS,,0,0,0,,然后其他浏览器 Safari、Chrome、Opera 也都采用了该功能 \N {\rENG} and then the other browsers Safari, Chrome, Opera, all also took up the feature
Dialogue: 0,0:07:54.00,0:08:03.20,CHS,,0,0,0,,并以一种或另一种方式实现它，现在它被认为是现代图形浏览器中预期 API 的一部分 \N {\rENG} and implemented it one way or another. And now it's kind of considered part of the expected API in a modern graphical browser
Dialogue: 0,0:08:07.00,0:08:11.00,CHS,,0,0,0,,那么为什么这是一件好事呢？ \N {\rENG} So why is this a good thing?
Dialogue: 0,0:08:11.00,0:08:16.00,CHS,,0,0,0,,我们必须在浏览器中实现编辑的其他控件是文本区域和文本 \N {\rENG} The other controls that we have to implementediting in a browser are text area and text \\TODO
Dialogue: 0,0:08:16.00,0:08:17.00,CHS,,0,0,0,,输入。 \N {\rENG} input.
Dialogue: 0,0:08:17.00,0:08:25.00,CHS,,0,0,0,,两者都受限于纯文本的原子块，你不能真正做很多 \N {\rENG} Both of which are constrained to atomic blobsof plain text you can't really do many of
Dialogue: 0,0:08:25.00,0:08:31.00,CHS,,0,0,0,,你想用它们做的事情，比如在其中做富文本是一个非首发，甚至 \N {\rENG} the things you want to do with them like doingrich text in them is a non starter and even
Dialogue: 0,0:08:31.00,0:08:36.00,CHS,,0,0,0,,添加一些有用的小部件或语法突出显示几乎是不可能的 在文本区域顶部执行 \N {\rENG} adding some helpful widgets or syntax highlightingis almost impossible to do on top of text
Dialogue: 0,0:08:36.00,0:08:39.00,CHS,,0,0,0,,。 \N {\rENG} area.
Dialogue: 0,0:08:39.00,0:08:45.00,CHS,,0,0,0,,所以很好的是，我们有一个替代方案，我们可以在浏览器中进行可靠的富文本编辑 \N {\rENG} So it's great then we have an alternativethat we can do solid rich text editing or
Dialogue: 0,0:08:45.00,0:08:51.00,CHS,,0,0,0,,或或多或少可靠的富文本编辑，例如 \N {\rENG} more or less solid rich text editing in abrowser, things like content management systems
Dialogue: 0,0:08:51.00,0:08:59.00,CHS,,0,0,0,,完全在线存在的内容管理系统，早期的代码编辑器也基于此。 \N {\rENG} that exist entirely online, earlier code editorswere also based on this.
Dialogue: 0,0:08:59.00,0:09:02.00,CHS,,0,0,0,,这太棒了。 \N {\rENG} This is wonderful.
Dialogue: 0,0:09:02.00,0:09:14.00,CHS,,0,0,0,,当然，除了它有问题之外，HTML 范围并不大，你可能 \N {\rENG} Except of course, it has problems a majorthing HTML scope is not gigantic, you might
Dialogue: 0,0:09:14.00,0:09:25.00,CHS,,0,0,0,,不想要整个范围，例如，CodeMirror 的第一个版本基于 contentEditable \N {\rENG} not want that whole scope for example, firstversion of CodeMirror it was based on contentEditable
Dialogue: 0,0:09:25.00,0:09:31.00,CHS,,0,0,0,,图像将整个表格链接到编辑器中，我不得不以某种方式处理这个问题。 \N {\rENG} images links whole tables into the editorI had to somehow deal with this.
Dialogue: 0,0:09:31.00,0:09:38.00,CHS,,0,0,0,,所以你可以过滤内容，无论如何你都想过滤内容， \N {\rENG} So you can do that you can filter content,you properly want to filter the content anyway,
Dialogue: 0,0:09:38.00,0:09:44.00,CHS,,0,0,0,,默认情况下它就是这样出来的，非常非常难看。 \N {\rENG} it comes out of this by default, it's very,very ugly.
Dialogue: 0,0:09:44.00,0:09:52.00,CHS,,0,0,0,,因此，现代 WYSIWYG 浏览器具有相当先进的机制来清除 \N {\rENG} So that modern WYSIWYG browsers have prettyadvanced mechanisms for cleaning out the HTML
Dialogue: 0,0:09:52.00,0:09:59.00,CHS,,0,0,0,,编辑器内部的 HTML，但是仍然存在所有浏览器差异， \N {\rENG} inside of the editor, but then there's stillall the browser differences, there's no spec,
Dialogue: 0,0:09:59.00,0:10:01.00,CHS,,0,0,0,,每个浏览器都没有规范。 \N {\rENG} each browser.
Dialogue: 0,0:10:01.00,0:10:07.00,CHS,,0,0,0,,这是编辑 HTML 真正含义的一个非常大的范围，光标在 \N {\rENG} This is a very big scope of what editing HTMLreally means, there's cursor motion through
Dialogue: 0,0:10:07.00,0:10:13.00,CHS,,0,0,0,,表格中移动，向表格中添加列，当您在定义列表中显示输入时会发生 \N {\rENG} tables, adding columns to table, what happenswhen you present enter in a definition list,
Dialogue: 0,0:10:13.00,0:10:18.00,CHS,,0,0,0,,什么，如果光标跨块元素的边界移动，光标位置到底是什么， \N {\rENG} what exactly is the cursor position if it'smoving across the boundaries of block elements,
Dialogue: 0,0:10:18.00,0:10:19.00,CHS,,0,0,0,,什么是有效的光标位置。 \N {\rENG} what is a valid cursor position.
Dialogue: 0,0:10:19.00,0:10:27.00,CHS,,0,0,0,,这些都是有效的问题，他们给出的答案略有不同。 \N {\rENG} These are all valid questions, they came upwith slightly different answers to them.
Dialogue: 0,0:10:27.00,0:10:29.00,CHS,,0,0,0,,然后是错误。 \N {\rENG} Then there's bugs.
Dialogue: 0,0:10:29.00,0:10:30.00,CHS,,0,0,0,,许多 \N {\rENG} Many
Dialogue: 0,0:10:30.00,0:10:31.00,CHS,,0,0,0,,错误。 \N {\rENG} bugs.
Dialogue: 0,0:10:31.00,0:10:36.00,CHS,,0,0,0,,我得到的感觉是，除了少数启动 \N {\rENG} The feeling I get is that no-one really maybeexcept for the few engineers that started
Dialogue: 0,0:10:36.00,0:10:41.00,CHS,,0,0,0,,这个东西的工程师之外，没有人真的可能想要实现这个，但这是需要和 \N {\rENG} this thing, no-one really felt like implementingthis but it was something that is needed and
Dialogue: 0,0:10:41.00,0:10:47.00,CHS,,0,0,0,,预期的东西，所以所有浏览器供应商都不得不以某种方式宣传这条龙 一个子浏览 \N {\rENG} expected and so all the browser vendors hadto somehow ad this dragon of a sub browser
Dialogue: 0,0:10:47.00,0:10:54.00,CHS,,0,0,0,,器以各种可怕的方式与所有东西交互，多年来一直存在语言错误和错误 \N {\rENG} that interacted with everything in all kindsof horrible ways, bugs with language and bug
Dialogue: 0,0:10:54.00,0:11:00.00,CHS,,0,0,0,,跟踪器，似乎没有人真正关心那么多。 \N {\rENG} trackers for years an years it seems no-onereally cared all that much.
Dialogue: 0,0:11:00.00,0:11:06.00,CHS,,0,0,0,,这种情况最近有所改善，目前在现代浏览器上，您确实可以 \N {\rENG} The situation has recently improved, currentlyon modern browsers you can really make some
Dialogue: 0,0:11:06.00,0:11:11.00,CHS,,0,0,0,,对用户编辑 HTML 时会发生什么做出一些假设，以前 \N {\rENG} assumptions about what is going to happento your HTML as the user is editing it, didn't
Dialogue: 0,0:11:11.00,0:11:17.00,CHS,,0,0,0,,在 CodeMirror 1 中并非如此，我只是一堆堆 \N {\rENG} used to be the case in CodeMirror 1, I havejust piles and piles of workarounds to deal
Dialogue: 0,0:11:17.00,0:11:19.00,CHS,,0,0,0,,解决所有这些奇怪问题的解决方法。 \N {\rENG} with all these weird issues.
Dialogue: 0,0:11:19.00,0:11:27.00,CHS,,0,0,0,,它只是一个文本编辑器，如果你真的支持丰富的内容，那就更糟了。 \N {\rENG} It was only a text editor, it will be a lotworse if you actually support rich content.
Dialogue: 0,0:11:27.00,0:11:36.00,CHS,,0,0,0,,所以，人们对此真的很恼火，然后有一代编辑， \N {\rENG} So, people really got annoyed with this andthen there is a generation of editors, it
Dialogue: 0,0:11:36.00,0:11:43.00,CHS,,0,0,0,,从代码编辑开始，他们只是说，“好吧，我们根本不打算碰这个，我们会 \N {\rENG} started with code editors, who just say, "Ok,we're not going to touch this at all, we'll
Dialogue: 0,0:11:43.00,0:11:50.00,CHS,,0,0,0,,自己想办法，我们 实现一切，所以我们实现了我们自己的选择， \N {\rENG} figure something out ourselves, we implementeverything, so we implement our own selection,
Dialogue: 0,0:11:50.00,0:11:56.00,CHS,,0,0,0,,只是 DOM 实际上是不可编辑的，我们通过捕获事件并更改 \N {\rENG} just the DOM is not actually editable, wepretend it is by capturing events and changing
Dialogue: 0,0:11:56.00,0:12:04.00,CHS,,0,0,0,,您在屏幕上看到的文档来响应这些事件来假装它是可编辑的。” \N {\rENG} your documents you see on the screen in responseto these events."
Dialogue: 0,0:12:04.00,0:12:11.00,CHS,,0,0,0,,第一个实现这一点的是 Ace代码编辑器，那时我还在 \N {\rENG} The first one to pull this off was the Acecode editor at that point I was still messing
Dialogue: 0,0:12:11.00,0:12:18.00,CHS,,0,0,0,,自己的代码编辑中搞乱 contentEditable，我认为这显然更优越， \N {\rENG} about with contentEditable in my own codeediting, I thought ok this is clearly superior,
Dialogue: 0,0:12:18.00,0:12:24.00,CHS,,0,0,0,,我只是放弃了内容编辑器，再也没有回去。 \N {\rENG} I just dropped content editor and never wentback.
Dialogue: 0,0:12:24.00,0:12:32.00,CHS,,0,0,0,,谷歌文档，使用这个，你看到的绿色闪烁是一个隐藏并定期显示的小 gif \N {\rENG} Google docs, uses this, what you see blinkingon the green is a little gif that's hidden
Dialogue: 0,0:12:32.00,0:12:40.00,CHS,,0,0,0,,，你可以很远，在桌面浏览器上，你可以使用这种技术获得良好的编辑 \N {\rENG} and shown periodically, you can very far,on desk top browsers you can get a good editing
Dialogue: 0,0:12:40.00,0:12:45.00,CHS,,0,0,0,,体验。 \N {\rENG} experience using this technique.
Dialogue: 0,0:12:45.00,0:12:51.00,CHS,,0,0,0,,在某些时候你确实会遇到问题，如果你完全保持自己的选择， \N {\rENG} At some point you do run into problems, ifyou maintain your own selection entirely,
Dialogue: 0,0:12:51.00,0:12:57.00,CHS,,0,0,0,,你会得到你盘子上双向文本的所有复杂性，你必须 \N {\rENG} you get all the complexity of bi directionaltext on your plate you have to implement what
Dialogue: 0,0:12:57.00,0:13:02.00,CHS,,0,0,0,,实现光标应该做的事情，如果它从右到左移动，那么 输入从左到右的 \N {\rENG} the cursor is supposed to be doing, if itmoves right to left, then enters left to right
Dialogue: 0,0:13:02.00,0:13:12.00,CHS,,0,0,0,,文本，有一个岛... \N {\rENG} text and there is an island of... if you aremixing Arabic or Hebrew or other scripts you
Dialogue: 0,0:13:12.00,0:13:19.00,CHS,,0,0,0,,- \N {\rENG} get islands inside of your paragraphs thatare running in different directions, people
Dialogue: 0,0:13:19.00,0:13:20.00,CHS,,0,0,0,,- \N {\rENG} need like this.
Dialogue: 0,0:13:20.00,0:13:25.00,CHS,,0,0,0,,就像阿拉伯语或希伯来语作家真的需要它来工作一样，如果它不起作用，你就不能对你的编辑器做太多事情，把 \N {\rENG} Like Arabic or Hebrew writers really needthis to be work, you can't do much with your
Dialogue: 0,0:13:25.00,0:13:32.00,CHS,,0,0,0,,它做好是非常困难的。 \N {\rENG} editor if it doesn't work, it's giganticallydifficult to get it right.
Dialogue: 0,0:13:32.00,0:13:37.00,CHS,,0,0,0,,内容菜单应该显示剪切和粘贴，如果您单击它，如果那里有不可编辑的 \N {\rENG} The content menu should shows cut and paste,if you click on it, if you have a non-editable
Dialogue: 0,0:13:37.00,0:13:45.00,CHS,,0,0,0,,gif，它不会知道。 \N {\rENG} gif there, it won't know.
Dialogue: 0,0:13:45.00,0:13:50.00,CHS,,0,0,0,,你可以找到这个的十六进制，这个的十六进制是 \N {\rENG} You can find the hex for this, the hex forthis is to pop-up a tiny transparent text
Dialogue: 0,0:13:50.00,0:13:56.00,CHS,,0,0,0,,当用户右键单击并在剪切或粘贴时挂钩正确的东西时，在光标下弹出一个微小的透明文本区域 \N {\rENG} area under the cursor when the user rightclicks and hooks up the right thing when he
Dialogue: 0,0:13:56.00,0:14:03.00,CHS,,0,0,0,,，你可以让它工作，但它的 痛苦或尴尬。 \N {\rENG} cuts or pastes, you can get it to work butit's painful or awkward.
Dialogue: 0,0:14:03.00,0:14:10.00,CHS,,0,0,0,,然后，移动界面，触摸界面变得普遍，并且 \N {\rENG} Then, mobile interfaces, touch interfacesbecame widespread and the integration Between
Dialogue: 0,0:14:10.00,0:14:20.00,CHS,,0,0,0,,选择和触摸界面之间的集成非常深刻和微妙，产生了原生选择，当你实际上不让浏览器知道选择时， \N {\rENG} the selection and touch interface is verydeep and very subtle, producing a native selection,
Dialogue: 0,0:14:20.00,0:14:25.00,CHS,,0,0,0,,一个原生字段来操作 \N {\rENG} a native field to manipulate the selectionwhen you are not actually letting the browser
Dialogue: 0,0:14:25.00,0:14:32.00,CHS,,0,0,0,,选择是 几乎不可能，我认为还没有人成功。 \N {\rENG} know about the selection is almost impossible,I don't think anyone has pulled it off yet.
Dialogue: 0,0:14:32.00,0:14:36.00,CHS,,0,0,0,,所以这也可能不是正确的解决方案。 \N {\rENG} So this may not be the right solution either.
Dialogue: 0,0:14:36.00,0:14:43.00,CHS,,0,0,0,,所以也许让我们在中间见面，这就是促使 ProseMirror 的想法， \N {\rENG} So maybe let's meet in the middle and thisis the idea that prompted ProseMirror, give
Dialogue: 0,0:14:43.00,0:14:51.00,CHS,,0,0,0,,给编辑器可见的 DOM，当用户做某事并生成一个事件时， \N {\rENG} the editor the visible DOM, when the userdoes something and it generates an event,
Dialogue: 0,0:14:51.00,0:15:01.00,CHS,,0,0,0,,我们介入并说做任何事情浏览器，我们会处理这个并且 get - 将它与 \N {\rENG} we step in and say doing do anything browser,we'll handle this and get - isolate this from
Dialogue: 0,0:15:01.00,0:15:08.00,CHS,,0,0,0,,contentEditable 的许多恐怖隔离开来，不再发生 DOM 的随机操作 \N {\rENG} a lot of the horrors of contentEditable, therandom manipulation by the DOM is no longer
Dialogue: 0,0:15:08.00,0:15:15.00,CHS,,0,0,0,,，它允许我们定义模型并且是 \N {\rENG} happens, it allows us to define the modeland be the
Dialogue: 0,0:15:15.00,0:15:23.00,CHS,,0,0,0,,唯一接触到的人，在旧方法中，DOM 是您的文档模型。 \N {\rENG} only one touching that, in the older approachthe DOM is your document model.
Dialogue: 0,0:15:23.00,0:15:30.00,CHS,,0,0,0,,您不保留自己的数据副本，让 DOM 确定文档的 \N {\rENG} You don't keep your own copy of the data youlet the DOM determine what the document looks
Dialogue: 0,0:15:30.00,0:15:35.00,CHS,,0,0,0,,外观，您不知道浏览器将对此做什么，这就像在流沙上构建， \N {\rENG} like, you don't know what the browser willdo with this, it's like building on quicksand,
Dialogue: 0,0:15:35.00,0:15:41.00,CHS,,0,0,0,,事情可能会发生变化，请注意您以某种方式依赖 现有的可能会 \N {\rENG} things might change, notes that you somehowdepending on existing might be replaced by
Dialogue: 0,0:15:41.00,0:15:53.00,CHS,,0,0,0,,被副本取代，完全控制提供您的文档模型是一件非常有用的事情，我 \N {\rENG} a copy, having full control offer your documentmodel is a very useful thing to do and I think
Dialogue: 0,0:15:53.00,0:16:04.00,CHS,,0,0,0,,认为最近出现的其他一些所见即所得也朝着这个方向发展。 \N {\rENG} some of the other WYSIWYGs that have croppedup recently are also moving in this direction.
Dialogue: 0,0:16:04.00,0:16:05.00,CHS,,0,0,0,,. \N {\rENG} .
Dialogue: 0,0:16:05.00,0:16:09.00,CHS,,0,0,0,,是的，ProseMirror 是从头开始设计的，假设我们有一个文档 \N {\rENG} Yeah, ProseMirror is designed from the groundup with the assumption that we have a document
Dialogue: 0,0:16:09.00,0:16:16.00,CHS,,0,0,0,,模型，然后有一个 DOM，DOM 是文档模型上的一个视图，文档 \N {\rENG} model and then there is a DOM, the DOM isa view on the document model, the document
Dialogue: 0,0:16:16.00,0:16:23.00,CHS,,0,0,0,,是实体的，我们完全拥有它，当它发生变化时，我们会更新 DOM 自己并向 \N {\rENG} is solid we have it entirely, when it's changedwe update the DOM ourselves and show the user
Dialogue: 0,0:16:23.00,0:16:34.00,CHS,,0,0,0,,用户显示伪可编辑的东西，它应该是可编辑的，但我们不让他们直接编辑 \N {\rENG} the pseudo editable thing, it's supposed tobe editable but we don't let them edict directly,
Dialogue: 0,0:16:34.00,0:16:41.00,CHS,,0,0,0,,，选择不是您可以在触摸界面上操作的真实选择， \N {\rENG} the selection is not a real selection youcan manipulate on a touch interface, bi directional
Dialogue: 0,0:16:41.00,0:16:45.00,CHS,,0,0,0,,双向文本的双向光标移动可以通过浏览器离开，我们想 \N {\rENG} cursor motion by bi directional text can beleft through the browser, we dent want to
Dialogue: 0,0:16:45.00,0:16:49.00,CHS,,0,0,0,,考虑一下，这样可以节省复杂性。 \N {\rENG} think about that, that saves complexity.
Dialogue: 0,0:16:49.00,0:16:54.00,CHS,,0,0,0,,当然，实现我们自己的文档模型和所有可能的更改也是非常 \N {\rENG} Of course implementing our own document modeland all possible changes is also a lot of
Dialogue: 0,0:16:54.00,0:17:00.00,CHS,,0,0,0,,复杂的，但我认为这是您作为文本编辑器想要的复杂性，您希望 \N {\rENG} complexity, but this is complexity I thinkyou want as a text editor, you want to define
Dialogue: 0,0:17:00.00,0:17:04.00,CHS,,0,0,0,,以一种可预测的、明确定义的方式来定义它。 \N {\rENG} it in one predictable, well-defined way.
Dialogue: 0,0:17:04.00,0:17:12.00,CHS,,0,0,0,,你想让它们可定制，你想在涉及到的时候去掉浏览器。 \N {\rENG} You want to make them customisable, you wantto cut out the browser when it comes to that.
Dialogue: 0,0:17:12.00,0:17:20.00,CHS,,0,0,0,,因此，我将稍微介绍一下 ProseMirror 文档模型，三个基础很像 \N {\rENG} So I'm going to go into ProseMirror documentmodel for a bit, three base much like the
Dialogue: 0,0:17:20.00,0:17:28.00,CHS,,0,0,0,,DOM，如果您有一个包含三个项目列表的文档，它看起来像这样。 \N {\rENG} DOM, if you have a document with a list ofthree items, it looks something like this.
Dialogue: 0,0:17:28.00,0:17:35.00,CHS,,0,0,0,,您现在得到一个列表或三个项目注释，其中包含一些文本内容的段落注释。 \N {\rENG} You get a list now or three item notes, paragraphnotes with some text content in it.
Dialogue: 0,0:17:35.00,0:17:40.00,CHS,,0,0,0,,它与 DOM 完全不同的一件事是它是一个持久数据结构， \N {\rENG} One thing that it does very differently fromthe DOM it's a persistent data structure,
Dialogue: 0,0:17:40.00,0:17:46.00,CHS,,0,0,0,,所以如果你更新它，你会创建一个新版本，而旧版本不会受到影响，所以你只是 \N {\rENG} so if you update it you create a new versionand the old version is untouched, so you just
Dialogue: 0,0:17:46.00,0:17:48.00,CHS,,0,0,0,,不去那里开始添加孩子，我不 不知道在哪里。 \N {\rENG} don't go in there and start adding children,I don't know where.
Dialogue: 0,0:17:48.00,0:17:58.00,CHS,,0,0,0,,有一组明确定义的可能更新，您可以应用更新来获取新文档。 \N {\rENG} There is a well-defined set of possible updatesand you apply an update to get a new document.
Dialogue: 0,0:17:58.00,0:18:03.00,CHS,,0,0,0,,这并不像听起来那么昂贵，如果您在此列表中添加一个项目，它可以进行数据共享 \N {\rENG} This is not as expensive as it sounds, itcan do data sharing if you an item to this
Dialogue: 0,0:18:03.00,0:18:11.00,CHS,,0,0,0,,，您只需重复使用旧项目注释并复制文档和列表 \N {\rENG} list here, you just reuse the old item notesand make a copy of the document and the list
Dialogue: 0,0:18:11.00,0:18:16.00,CHS,,0,0,0,,注释，列表注释中的第四个孩子，您只是在复制两个笔记，而 \N {\rENG} notes, the fourth child in the list notes,you are only copying two notes rather than
Dialogue: 0,0:18:16.00,0:18:20.00,CHS,,0,0,0,,不是整个文档结构。 \N {\rENG} your whole document structure.
Dialogue: 0,0:18:20.00,0:18:25.00,CHS,,0,0,0,,ProseMirror 所做的另一件事与 DOM 不同，当您有行内内容时， \N {\rENG} Another thing that ProseMirror does differentlyfrom the DOM, when you have in line content
Dialogue: 0,0:18:25.00,0:18:34.00,CHS,,0,0,0,,这就是您如何表示带有蜜蜂链接和注释文本的段落，您创建 \N {\rENG} this is how you represent a paragraph witha bees of link and note text in it, you create
Dialogue: 0,0:18:34.00,0:18:40.00,CHS,,0,0,0,,一个带有例如强注释的子树，然后将内容放在 强下那。 \N {\rENG} a subtree with for example a strong note andyou put the content that's strong under that.
Dialogue: 0,0:18:40.00,0:18:47.00,CHS,,0,0,0,,ProseMirror 实际上是线性的，其中行内的段落内容始终是 \N {\rENG} ProseMirror actually makes linear, where inline paragraph content is always a sequence
Dialogue: 0,0:18:47.00,0:18:54.00,CHS,,0,0,0,,带有样式信息和图像或注释的文本序列，它们可以出现在这里， \N {\rENG} of pieces of text with styling informationand images or notes that can appear here,
Dialogue: 0,0:18:54.00,0:18:58.00,CHS,,0,0,0,,它们不嵌套，超出段落级别没有嵌套，您可以看到这是怎么回事 \N {\rENG} they don't nest, beyond the paragraph levelthere is no nesting you can see how this is
Dialogue: 0,0:18:58.00,0:19:00.00,CHS,,0,0,0,,比这更难读。 \N {\rENG} harder to read than this.
Dialogue: 0,0:19:00.00,0:19:05.00,CHS,,0,0,0,,当你在代码中处理它时也是一样的，很多你想做的事情 \N {\rENG} It's the same when you are dealing with itin code, a lot of the things you want to do
Dialogue: 0,0:19:05.00,0:19:10.00,CHS,,0,0,0,,在这方面要容易得多，例如，验证你没有两次强调一段文本 \N {\rENG} are much easier on this, for example, verifyingthat you are not emphasising a piece of text
Dialogue: 0,0:19:10.00,0:19:18.00,CHS,,0,0,0,,，这是微不足道的，这个树表示是一个 树表示的痛苦类似地， \N {\rENG} twice, it's trivial and this tree representationis a pain in the... tree representation similarly
Dialogue: 0,0:19:18.00,0:19:25.00,CHS,,0,0,0,,如果我们想表示段落中的位置，我们可以只是一个字符偏移量，我们 \N {\rENG} if we want to represent positions in the paragraphwe can just a character offset and we
Dialogue: 0,0:19:25.00,0:19:28.00,CHS,,0,0,0,,不必担心树关系。 \N {\rENG} don't have to worry about tree relations.
Dialogue: 0,0:19:28.00,0:19:35.00,CHS,,0,0,0,,所以这是一个巨大的胜利，让定义很多东西变得更容易。 \N {\rENG} So this was a big win and made it easier todefine a lot of things.
Dialogue: 0,0:19:35.00,0:19:39.00,CHS,,0,0,0,,那么让我们看看当 ProseMirror 捕获事件时会发生什么。 \N {\rENG} So let's see what happens when ProseMirrorcaptures events.
Dialogue: 0,0:19:39.00,0:19:45.00,CHS,,0,0,0,,你有你的编辑器，它渲染了一段可编辑的 DOM，对应于 \N {\rENG} You have your editor, it's rendered a pieceof editable DOM corresponding to the document
Dialogue: 0,0:19:45.00,0:19:52.00,CHS,,0,0,0,,它在内存软件中的文档，有人按下“A”，我们为此捕获一个事件 \N {\rENG} it has itself in memory software, and someonepresses 'A', we capture an event for that
Dialogue: 0,0:19:52.00,0:19:55.00,CHS,,0,0,0,,并创建一个更改对象。 \N {\rENG} and create a change object.
Dialogue: 0,0:19:55.00,0:20:02.00,CHS,,0,0,0,,ProseMirror 中的更改是您可以存储和传递的一流对象，我们 \N {\rENG} Changes in ProseMirror are first class objectswhich you can store and pass around and we'll
Dialogue: 0,0:20:02.00,0:20:04.00,CHS,,0,0,0,,稍后再讨论。 \N {\rENG} come back to that later.
Dialogue: 0,0:20:04.00,0:20:08.00,CHS,,0,0,0,,然后我们将更改对象应用于我们当前的文档，获取新文档， \N {\rENG} Then we apply the change object to our currentdocuments, get the new documents, make that
Dialogue: 0,0:20:08.00,0:20:16.00,CHS,,0,0,0,,制作当前文档并安排 DOM 更新，类似地，如果您按“退格”，您只需 \N {\rENG} the current documents and schedule a DOM update,similarly if you press 'Backspace', you just
Dialogue: 0,0:20:16.00,0:20:22.00,CHS,,0,0,0,,使用退格计算要删除的内容，创建更改 ，获取 \N {\rENG} compute what you want to be deleting withbackspace, create a change, take the content
Dialogue: 0,0:20:22.00,0:20:29.00,CHS,,0,0,0,,剪贴板的内容，将其传递到我们的文档格式中，并用这个文档片段替换选择， \N {\rENG} of the clipboard, pass it into our documentformat and replace the selection with this
Dialogue: 0,0:20:29.00,0:20:35.00,CHS,,0,0,0,,以获得另一个更改对象。 \N {\rENG} document fragment to get another change object.
Dialogue: 0,0:20:35.00,0:20:40.00,CHS,,0,0,0,,然后通过更新 DOM 来完成，因为我使用请求信息框架安排更新 \N {\rENG} Updating the DOM is then done by, as I schedulingupdates using request information frames,
Dialogue: 0,0:20:40.00,0:20:46.00,CHS,,0,0,0,,，下次浏览器进行实际重绘时，它将首先运行代码， \N {\rENG} the next time the browser does an actual redrawit will first run are code which is responsible
Dialogue: 0,0:20:46.00,0:20:52.00,CHS,,0,0,0,,负责确保 DOM 反映当前文档关于持久性的好处 \N {\rENG} for making sure the DOM reflects the currentdocument the nice thing about the persistent
Dialogue: 0,0:20:52.00,0:20:59.00,CHS,,0,0,0,,停靠搜索我们可以做很多反应，我们可以将文档与当前文档分开， \N {\rENG} dock searches we can do pretty much react,we can div the document with the current document
Dialogue: 0,0:20:59.00,0:21:04.00,CHS,,0,0,0,,并仅对DOM 进行必要的更改以移动到新文档，这 \N {\rENG} and make the changes only that are necessaryto the DOM to move to the new document, this
Dialogue: 0,0:21:04.00,0:21:13.00,CHS,,0,0,0,,是非常高效和快速的，我们只需要做一点 比较，好的，这里没有任何变化 \N {\rENG} is insanely efficient and fast, we can justdo one point to compare, ok, nothing changed
Dialogue: 0,0:21:13.00,0:21:16.00,CHS,,0,0,0,,，继续下一个音符。 \N {\rENG} here and move on to the next note.
Dialogue: 0,0:21:16.00,0:21:28.00,CHS,,0,0,0,,当然它并不完全完美，在某些情况下解析不会触发好的事件， - 你 \N {\rENG} Of course it's not entirely perfect, in somecases parses do not fire good events, - you
Dialogue: 0,0:21:28.00,0:21:35.00,CHS,,0,0,0,,写点击并选择这个世界的另一种拼写，然后它只会修改 DOM \N {\rENG} write click and choose another spelling ofthis world, then it will just modify the DOM
Dialogue: 0,0:21:35.00,0:21:40.00,CHS,,0,0,0,,然后说，“输入”，意思是改变了，你不要 对此一无所知。 \N {\rENG} and then say, "Input", meaning something changed,you don't know anything about it.
Dialogue: 0,0:21:40.00,0:21:46.00,CHS,,0,0,0,,所以，我们必须处理这个问题，在这种情况下，我们只需要 DOM 的一部分，比如 \N {\rENG} So, we have to deal with that and in thiscase we just take the part of the DOM, like
Dialogue: 0,0:21:46.00,0:21:51.00,CHS,,0,0,0,,光标周围的块元素，重新解析它们，根据我们 \N {\rENG} the block elements around the cursor, reparsethose, div those with our understanding of
Dialogue: 0,0:21:51.00,0:21:57.00,CHS,,0,0,0,,对文档的这些部分的外观的理解来划分它们并进行更改 从那开始，幸运的是， \N {\rENG} what those parts of that document look likeand arrive at change from that, fortunately
Dialogue: 0,0:21:57.00,0:22:04.00,CHS,,0,0,0,,我只是在简单的文本更改中遇到了这个问题，并且派生一个简单的文本 \N {\rENG} I've only run into this problem for simpletextual changes and deriving a simple text
Dialogue: 0,0:22:04.00,0:22:13.00,CHS,,0,0,0,,更改是安全的，那里不会发生任何奇怪的事情，到目前为止这运作良好我仍然希望 \N {\rENG} change is safe, nothing weird can happen there,so far this is working well I'm still expecting
Dialogue: 0,0:22:13.00,0:22:17.00,CHS,,0,0,0,,在某个时候遇到更多问题 这里。 \N {\rENG} at some point to run into more problems here.
Dialogue: 0,0:22:17.00,0:22:28.00,CHS,,0,0,0,,因此，让所有这些持久对象以一种很好的价值方式表示一切，我们可以定义 \N {\rENG} So, having all these persistent objects representingeverything in a nice value way, we can define
Dialogue: 0,0:22:28.00,0:22:36.00,CHS,,0,0,0,,一种更改代数，基本操作是将更改应用于文档。 \N {\rENG} a kind of algebra of changes, the basic operationis applying the change to a document.
Dialogue: 0,0:22:36.00,0:22:41.00,CHS,,0,0,0,,在这里，我们有一个蓝色的东西代表一个文档，一个橙色的东西代表一个变化，我们应用 \N {\rENG} Here we have a blue thing for a document andan orange thing for a change and we apply
Dialogue: 0,0:22:41.00,0:22:48.00,CHS,,0,0,0,,它来获取一个新的文档，在这种情况下，我们删除字符集 2 和 8 之间的第 0 段中的部分 \N {\rENG} that getting a new document, in this casewe delete the part in 0 paragraph between
Dialogue: 0,0:22:48.00,0:22:58.00,CHS,,0,0,0,,，我们得到一个新的文档对象和 也是一张地图。 \N {\rENG} character off set 2 and 8, we get a new documentobject and also a map.
Dialogue: 0,0:22:58.00,0:23:06.00,CHS,,0,0,0,,地图是位置地图，它是一种将文档更改前版本中的 \N {\rENG} A map is a position map, it's a way to associatepositions in the pre-change version of the
Dialogue: 0,0:23:06.00,0:23:11.00,CHS,,0,0,0,,位置与更改后文档中的位置相关联的方法，在这种情况下，我们可以查询此地图 \N {\rENG} document with positions in the post changedocument, in this case we can query this map
Dialogue: 0,0:23:11.00,0:23:18.00,CHS,,0,0,0,,以询问光标在第一段中位置 11 的位置 旧文档， \N {\rENG} to ask cursor position in the first paragraphat position 11 in the old document, where
Dialogue: 0,0:23:18.00,0:23:19.00,CHS,,0,0,0,,新文档中的这个在哪里。 \N {\rENG} is this in the new document.
Dialogue: 0,0:23:19.00,0:23:26.00,CHS,,0,0,0,,它会说，“它的位置是 05”，意思是第一个字符中的第五个字符......这 \N {\rENG} It will say, "It's positioned 05", meaningthe fifth character in the first... this is
Dialogue: 0,0:23:26.00,0:23:31.00,CHS,,0,0,0,,主要用于使光标随着文档的变化而移动，所以它不应该 \N {\rENG} mainly used for making the cursor move asthe document changes, so it shouldn't jump
Dialogue: 0,0:23:31.00,0:23:33.00,CHS,,0,0,0,,跳来跳去，而是保持在它的位置。 \N {\rENG} around but stay in its position.
Dialogue: 0,0:23:33.00,0:23:36.00,CHS,,0,0,0,,你可以 \N {\rENG} There is a bunch of nice things you can
Dialogue: 0,0:23:36.00,0:23:42.00,CHS,,0,0,0,,用它做很多好事，比如检查你刚刚 \N {\rENG} do with this, like checking pieces of thedocument you just create two positions in
Dialogue: 0,0:23:42.00,0:23:48.00,CHS,,0,0,0,,在文档中围绕你感兴趣的部分创建两个位置的文档片段，你不断将它们映射到新文档 \N {\rENG} the document around the part you are interestedin, you keep mapping those to the new document
Dialogue: 0,0:23:48.00,0:23:54.00,CHS,,0,0,0,,，你最终知道在哪里 您正在检查的文本结束了，它 \N {\rENG} and you end up knowing where the text youare checking ended up, it's also essential
Dialogue: 0,0:23:54.00,0:24:01.00,CHS,,0,0,0,,对于协作编辑也是必不可少的，它允许我们通过映射与更改对象关联的位置 \N {\rENG} for collaborative editing, it allows us bymapping the positions associated with the
Dialogue: 0,0:24:01.00,0:24:07.00,CHS,,0,0,0,,来将更改从一个文档移动到该文档的另一个版本。 \N {\rENG} change object to move changes from one documentto another version of that document.
Dialogue: 0,0:24:07.00,0:24:15.00,CHS,,0,0,0,,因此，例如，如果我们在删除操作之外还有另一个更改对象说 \N {\rENG} So, for example, if we had beyond this deleteoperation we had another change object saying,
Dialogue: 0,0:24:15.00,0:24:25.00,CHS,,0,0,0,,“在位置 11 处插入一个字符”，我们现在可以说相同的更改但应用于 \N {\rENG} "Insert a character at position 11", we cannow say that same change but applied to the
Dialogue: 0,0:24:25.00,0:24:32.00,CHS,,0,0,0,,第二个文档是，在位置 5 处插入相同的字符 ，因此，如果您 \N {\rENG} second document is, insert the same characterat position 5, so if you have a collaborative
Dialogue: 0,0:24:32.00,0:24:40.00,CHS,,0,0,0,,设置了协作编辑并且两个用户同时进行，则其中一个最终会先进行， \N {\rENG} editing set up and two users make it concurrently,one of them will end up going first and the
Dialogue: 0,0:24:40.00,0:24:46.00,CHS,,0,0,0,,另一个将具有他们所做的更改，但他们无法 \N {\rENG} other one will have this change that theyhave made, but that they're not able to apply
Dialogue: 0,0:24:46.00,0:24:49.00,CHS,,0,0,0,,应用于当前 文件，因为文件在此期间发生了变化。 \N {\rENG} to the current document because the documentchanged in the meantime.
Dialogue: 0,0:24:49.00,0:24:55.00,CHS,,0,0,0,,他们可以使用这种方法来获取其他用户所做的更改，移动他们自己的更改， \N {\rENG} They can use this approach to take the changethat the other user made, move their own changeover
Dialogue: 0,0:24:55.00,0:25:01.00,CHS,,0,0,0,,然后应用它并重新尝试将其推送到服务器，所以它有点像，到达 \N {\rENG} it and then apply it and retry pushing itto the server, so it's kind of like, get to
Dialogue: 0,0:25:01.00,0:25:07.00,CHS,,0,0,0,,基地，你尝试推送，你得到一个 冲突，你尝试在本地rebase，然后你尝试 \N {\rENG} base, you try to push, you get a conflict,you try to rebase locally and then you try
Dialogue: 0,0:25:07.00,0:25:12.00,CHS,,0,0,0,,再次repush，效果很好，实际上有很多，你可以 \N {\rENG} to repush again, it works quite well, thereis quite a bit to it actually, you can find
Dialogue: 0,0:25:12.00,0:25:20.00,CHS,,0,0,0,,在我的博客上找到很长的歧视，效果很好，比较简单和可靠 \N {\rENG} a long discrimination on my blog, it worksquite well, it's a relatively simple and solid
Dialogue: 0,0:25:20.00,0:25:21.00,CHS,,0,0,0,,进行协作编辑的方式。 \N {\rENG} way to do collaborative editing.
Dialogue: 0,0:25:21.00,0:25:28.00,CHS,,0,0,0,,这有更多的应用，比如更改跟踪，如果您只是保留所有更改的历史记录 \N {\rENG} There is more applications of this, say changetracking, if you just keep a history of all
Dialogue: 0,0:25:28.00,0:25:32.00,CHS,,0,0,0,,，您总是可以找出文档的来源， \N {\rENG} your changes, you can always find out wherea piece of the document originated, stuff
Dialogue: 0,0:25:32.00,0:25:34.00,CHS,,0,0,0,,诸如此类。 \N {\rENG} like that.
Dialogue: 0,0:25:34.00,0:25:40.00,CHS,,0,0,0,,我敢肯定还有更多，我们还没有真正探索到这一步，但这是一个不错的 \N {\rENG} I'm sure there is more, we haven't reallyexplored this far yet, but it's a nice place
Dialogue: 0,0:25:40.00,0:25:42.00,CHS,,0,0,0,,地方，很好的基础。 \N {\rENG} to, nice basis to build on.
Dialogue: 0,0:25:42.00,0:25:47.00,CHS,,0,0,0,,然后我想，很简单的谈一下未来。 \N {\rENG} Then I want to, very briefly talk about thefuture.
Dialogue: 0,0:25:47.00,0:25:55.00,CHS,,0,0,0,,因此，W 3 C 正在对此 contentEditable 标准进行更新，这将允许 \N {\rENG} So, the W 3 C is working on an update to thiscontentEditable standard which would allow
Dialogue: 0,0:25:55.00,0:26:01.00,CHS,,0,0,0,,一种新的 contentEditable 模式，您应该这样做， \N {\rENG} a new mode of contentEditable, where you aresupposed to do exactly this, the document
Dialogue: 0,0:26:01.00,0:26:08.00,CHS,,0,0,0,,文档不可编辑，您应该捕获事件并编辑库存 你自己，那么 \N {\rENG} isn't editable, you are supposed to captureevents and edit the inventory yourself, then
Dialogue: 0,0:26:08.00,0:26:12.00,CHS,,0,0,0,,他们还必须为 \N {\rENG} they will also have to define a few more eventsfor stuff like the spell checking issue that
Dialogue: 0,0:26:12.00,0:26:20.00,CHS,,0,0,0,,我之前展示的拼写检查问题和更多类似的东西定义更多事件，但是是的，那会很好，因为它 \N {\rENG} I showed before and a bunch more like this,but yeah, that would be nice because it relives
Dialogue: 0,0:26:20.00,0:26:28.00,CHS,,0,0,0,,让浏览器供应商重新维护了整个可怕的 blob 代码，它让编辑器 \N {\rENG} the browser vendors of maintaining this wholehorrible blob of code and it gives editor
Dialogue: 0,0:26:28.00,0:26:34.00,CHS,,0,0,0,,实现者了解如何实现一个健壮的实体编辑器，而不会 \N {\rENG} implementers a view of how to implement arobust solid editor, without going insane
Dialogue: 0,0:26:34.00,0:26:37.00,CHS,,0,0,0,,在这个过程中发疯。 \N {\rENG} in the process.
Dialogue: 0,0:26:37.00,0:26:42.00,CHS,,0,0,0,,当然，你永远不知道 W 3 C 标准什么时候会真正出现在浏览器中，但 \N {\rENG} Of course, you never know when W 3 C standardwill actually end up in browsers, but I'm
Dialogue: 0,0:26:42.00,0:26:46.00,CHS,,0,0,0,,我听说浏览器对此很感兴趣，可能出于我提到的原因， \N {\rENG} told that browsers are enthusiastic aboutthis, probably for the reasons I mentioned,
Dialogue: 0,0:26:46.00,0:26:51.00,CHS,,0,0,0,,它可能会发生，但规范还没有完成 然而，这可能会很 \N {\rENG} it will probably be happening, but the specificationisn't finished yet, it will probably be a
Dialogue: 0,0:26:51.00,0:26:53.00,CHS,,0,0,0,,长一段时间。 \N {\rENG} long time.
Dialogue: 0,0:26:53.00,0:27:00.00,CHS,,0,0,0,,这是 URL，ProseMirror.net 和Github.com/ProseMirror。 \N {\rENG} This is the URLs, the ProseMirror.net andGithub.com/ProseMirror.
Dialogue: 0,0:27:00.00,0:27:11.00,CHS,,0,0,0,,随意使用它，它还没有完成，但它可以按原样工作，主要 \N {\rENG} Feel free to play with it, it's not finishedyet but it works as it is, the major big thing
Dialogue: 0,0:27:11.00,0:27:18.00,CHS,,0,0,0,,需要改进的是 API 或语言，用于定义您自己的文档方案 \N {\rENG} that has to improve is the API or languagefor defining your own document schemers and
Dialogue: 0,0:27:18.00,0:27:24.00,CHS,,0,0,0,,并灵活处理您在文档中可能需要的所有内容 策划者。 \N {\rENG} having flexible for all the things you mightwant in your document schemer.
Dialogue: 0,0:27:24.00,0:27:31.00,CHS,,0,0,0,,我们将于周一在柏林就这个项目举行一次见面会，如果您认为您 \N {\rENG} We are having a meet up on Monday around thisproject here in Berlin, if you think you might
Dialogue: 0,0:27:31.00,0:27:38.00,CHS,,0,0,0,,可能感兴趣，请前往讨论。ProseMirror.net，一个讨论论坛，其中一个主题是 \N {\rENG} be interested, go to discuss.ProseMirror.net,a discussion forum and one of the topics is
Dialogue: 0,0:27:38.00,0:27:39.00,CHS,,0,0,0,,这次 \N {\rENG} this
Dialogue: 0,0:27:39.00,0:27:42.00,CHS,,0,0,0,,见面，欢迎您申请 出色地。 \N {\rENG} meet up, you are welcome to apply as well.
Dialogue: 0,0:27:42.00,9:00:00.00,CHS,,0,0,0,,就是这样，谢谢你的收听。 \N {\rENG} That's it, thank you for listening.
